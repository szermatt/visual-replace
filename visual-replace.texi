\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename visual-replace.info
@documentencoding UTF-8
@ifinfo
@*Generated by Sphinx.@*
@end ifinfo
@settitle Visual Replace
@defindex ge
@paragraphindent 0
@exampleindent 4
@finalout
@dircategory Emacs
@direntry
* visual-replace: (visual-replace.info). A nicer interface for string-replace and query-replace
                        that supports previews.
@end direntry

@c %**end of header

@copying
@quotation
Visual-Replace

Stephane Zermatten

Copyright @copyright{} 2020-2024, Stephane Zermatten
@end quotation

@end copying

@titlepage
@title Visual Replace
@insertcopying
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top Visual Replace
@insertcopying
@end ifnottex

@c %**start of body
@anchor{index doc}@anchor{0}
Visual Replace provides a nicer interface to Query-Replace@footnote{https://www.gnu.org/software/emacs/manual/html_node/emacs/Query-Replace.html}
than the built-in one.

The main improvements are:

@quotation


@itemize *

@item 
The prompt of Visual Replace includes both the text to be
replaced and the replacement. This makes it easier to craft
possibly complex regular expression search and replace.

@item 
You can modify the scope and type of the search-and-replace
command.

@item 
You can see what is going to be modified as you edit the command
arguments.
@end itemize
@end quotation

Visual Replace is just an interface. The actual replacements are
always done by the standard Emacs commands.

@menu
* Comparison with other packages:: 
* Contents:: 
* Index:: 

@end menu

@node Comparison with other packages,Contents,Top,Top
@anchor{index comparison-with-other-packages}@anchor{1}@anchor{index visual-replace}@anchor{2}
@chapter Comparison with other packages


What seems to be unique about Visual Replace is the ability to edit
both the thing to be replaced and the replacement at the same time.
The other packages I’ve found make it a 2-step process.

visual-regexp@footnote{https://github.com/benma/visual-regexp.el} also
supports a preview, but uses its own search-and-replace mechanism and
only supports a regexp mode.

anzu@footnote{https://github.com/emacsorphanage/anzu} also supports a
preview and supports a more powerful query-replace mechanism, and much
more. It was abandoned for a long time, but has been recently taken up
by a new maintainer.

@node Contents,Index,Comparison with other packages,Top
@anchor{index contents}@anchor{3}
@chapter Contents


@menu
* Installation:: 
* Usage:: 
* Contributing:: 

@end menu

@node Installation,Usage,,Contents
@anchor{install doc}@anchor{4}@anchor{install installation}@anchor{5}
@section Installation


Visual Replace requires Emacs 26.1 or later.

To install Visual Replace, you can:


@itemize *

@item 
On a recent version of Emacs (29 or later), install from the
repository by doing @code{M-x package-vc-install
https://github.com/szermatt/visual-replace}

@item 
Use an alternative package managers that support installing
from source, such as straight@footnote{https://github.com/radian-software/straight.el}, shown here:

@example
(use-package visual-replace
  :straight (:type git :repo "https://github.com/szermatt/visual-replace.git"))
@end example

@item 
Install it the old-fashioned way, and copy visual-replace.el@footnote{https://raw.githubusercontent.com/szermatt/visual-replace/refs/heads/master/visual-replace.el}
into your @code{.emacs.d} directory, but you’ll have to keep it
up-to-date manually as well
@end itemize

@node Usage,Contributing,Installation,Contents
@anchor{usage doc}@anchor{6}@anchor{usage usage}@anchor{7}
@section Usage


@menu
* Calling Visual Replace:: 
* Visual Replace Mode:: 
* Single replacements:: 
* Commands:: 
* Keymaps:: 
* Hooks:: 
* Limitations:: 

@end menu

@node Calling Visual Replace,Visual Replace Mode,,Usage
@anchor{usage calling-visual-replace}@anchor{8}
@subsection Calling Visual Replace


Visual Replace needs to be bound to a key to be of any use.

Choose a reasonably short key combination and bind
@code{visual-replace} to it. It should be reasonably short, because
@code{visual-replace}, by default, uses the key combination it’s
called with as prefix for the commands available in the minibuffer.

Here’s an example that uses @code{M-%} as key combination, since this
is bound by default to @code{query-replace}, which Visual Replace
then, well, replaces:

@example
(use-package visual-replace
  :defer t
  :bind (("M-%" . visual-replace)
         :map isearch-mode-map
         ("M-%" . visual-replace-from-isearch)))
@end example

The above example also binds @code{M-%} in isearch, so you can just
switch from isearch to Visual Replace.

An alternative, which you might prefer to try things out, is to
replace @code{query-replace} and others with Visual Replace. This
then uses whatever shortcut you’ve already installed.

@example
(use-package visual-replace
  :defer nil
  :config
  (visual-replace-global-mode 1))
@end example

Once this is done, launch @code{visual-replace} with the keybinding you chose.

@node Visual Replace Mode,Single replacements,Calling Visual Replace,Usage
@anchor{usage visual-replace-mode}@anchor{9}
@subsection Visual Replace Mode


When Visual Replace is running, you’ll see, something like the
following in the minibuffer @cite{Replace from point […]: ┃ →}. The text
before the arrow is the text to replace and the text after the arrow
is the replacement. You can navigate back and forth with @code{TAB} or
by moving the cursor.

See also the example below.

@quotation

@image{visual-replace-figures/capture_blue,,,Screen grab showing Visual Replace in action,png}
@end quotation

Once both fields are filled, press @code{RET} to execute the
replacement.

When there’s no replacement @code{RET} instead moves the cursor to the
replacement, in case muscle memory kicks in and you type: `text to
replace' @code{RET} `replacement' @code{RET}. That’ll work.

The prompt also displays the mode of replacement:


@itemize *

@item 
`text' → `replacement' executes @cite{string-replace}

@item 
`text' →? `replacement' executes @cite{query-replace}

@item 
`text' →.* `replacement' executes @cite{replace-regexp}

@item 
`text' →?.* `replacement' executes @cite{query-replace-regexp}
@end itemize

While @cite{visual-replace} is active, it scrolls the window to keep at
least one example of matches visible. You can also press up and down
to go through the matches. Don’t worry, though: the cursor goes back
to the original position once you leave Visual Replace.

In Visual Replace mode:


@itemize *

@item 
@code{TAB} navigates between the text to replace and the
replacement string

@item 
@code{RET} switches to the replacement string, the first time, then
executes the replacement

@item 
@code{M-% r} toggles regexp mode on and off. You know this mode is
on when a @code{.*} follows the arrow.

@item 
@code{M-% q} toggles query mode one and off, that is, it toggles
between calling @code{replace-string} and @code{query-replace}.
You know this mode is on when a @code{?} follows the arrow. See
also @ref{a,,Single replacements} for an alternative way of replacing only some
matches.

@item 
@code{M-% SPC} switches between different scopes: full buffer, from
point, in region. The scope is indicated in the prompt.
Additionally, for from point and in region, the region is
highlighted.

@item 
@code{M-% w} toggle limiting search to whole words. You know this
mode is on when a @code{w} follows the arrow.

@item 
@code{M-% c} toggle case-fold. You know this mode is on when a
@code{c} follows the arrow.

@item 
@code{M-% s} toggle lax whitespace. You know this mode is on when
@code{(lax ws)} follows the arrow.

@item 
@code{<up>} and @code{<down>} move the cursor to the next or
previous match, scrolling if necessary.

@item 
@code{M-% a} applies a single replacement, to the match right under
the cursor or following the cursor, then move on to the next match.
With a prefix argument N, apply N replacements. See also @ref{a,,Single replacements}.

@item 
@code{M-% u} calls @code{undo} on the original buffer, to revert a
previous replacement. With a prefix argument N, repeat undo N times.

@item 
As usual, @code{C-p} and @cite{C-n} go up and down the history, like on any prompt.
@end itemize

(Reminder: replace `M-%' with the keyboard shortcut you chose.)

If you leave @code{visual-replace} without confirming, with @code{C-g}, you can
continue where you left off next time by going up in the history.

See Search@footnote{https://www.gnu.org/software/emacs/manual/html_node/emacs/Search.html}
in the Emacs manual for details of the different modes listed above.

@node Single replacements,Commands,Visual Replace Mode,Usage
@anchor{usage single}@anchor{a}@anchor{usage single-replacements}@anchor{b}
@subsection Single replacements


If you want to replace only `some' matches within the scope, you can:


@itemize *

@item 
use the @code{query-replace} UI to go through all matches using
@code{M-% q}, then typing @code{RET} to enter Query Replace mode. `

@item 
in preview mode, click on the replacements you want to apply. You
can scroll the buffer as needed, normally or, from the minibufer
with @code{<up>} and @code{<down>}.

@item 
navigate to the replacements you want to apply with @code{<up>} and
@code{<down>}, the call @code{M-% a} to apply one replacement.

On Emacs 29.1 or later, this enters a mode that allows applying
replacement with @code{a}, the last part of the key sequence, and
also moving through the matches with @code{<down>} or @code{<up>}.
@code{u} reverts the last replacement.
@end itemize

@node Commands,Keymaps,Single replacements,Usage
@anchor{usage commands}@anchor{c}@anchor{usage id1}@anchor{d}
@subsection Commands


@geindex command; visual-replace
@geindex command; visual-replace-thing-at-point
@geindex command; visual-replace-selected
@geindex command; visual-replace-from-isearch


@itemize *

@item 
@code{visual-replace} is the main command that starts Visual Replace and
then executes the search-and-replace. It can replace @code{replace-string},
@code{query-replace}, @code{replace-regexp} and @code{query-replace-regexp}.

@item 
@code{visual-replace-thing-at-point} starts a visual replace session with
the symbol at point as text to replace.

@item 
@code{visual-replace-selected} starts with the text within the current
active region as text to replace.

@item 
@code{visual-replace-from-isearch} switches from an active isearch
session to @code{visual-replace}, keeping the current search text and
settings, such as regexp mode. This is meant to be called while
isearch is in progress, and bound to @code{isearch-mode-map}.
@end itemize

@geindex command; visual-replace-toggle-regexp
@geindex command; visual-replace-toggle-scope
@geindex command; visual-replace-toggle-query
@geindex command; visual-replace-toggle-word
@geindex command; visual-replace-toggle-case-fold
@geindex command; visual-replace-toggle-lax-ws
@geindex command; visual-replace-next-match
@geindex command; visual-replace-prev-match
@geindex command; visual-replace-apply-one
@geindex command; visual-replace-apply-one-repeat
@geindex command; visual-replace-undo
@geindex variable; visual-replace-transient-map

The following commands are meant to be called while in Visual Replace
mode, from @code{visual-mode-map}. By default, they’re bound in
@code{visual-replace-secondary-mode-map}:


@itemize *

@item 
@code{visual-replace-toggle-regexp} toggles regexp mode on and off.

@item 
@code{visual-replace-toggle-scope} changes the scope of the search.

@item 
@code{visual-replace-toggle-query} toggles the query mode on and off.

@item 
@code{visual-replace-toggle-word} toggles the word mode on and off.

@item 
@code{visual-replace-toggle-case-fold} toggles the case fold mode on and off.

@item 
@code{visual-replace-toggle-lax-ws} toggles the lax whitespace mode on and off.

@item 
@code{visual-replace-next-match} moves cursor to the next match

@item 
@code{visual-replace-prev-match} moves cursor to the previous match

@item 
@code{visual-replace-apply-one} applies a single replacement, to the
match at or after the cursor, then moves on to the next match. With a
prefix argument N, apply N replacements instead of just one.

This command, used together with @code{visual-replace-next-match}
and @code{visual-replace-prev-match} is in many cases functionally
equivalent to using the query mode, but with a different interface
that the possibility of changing the query as you go.

@item 
@code{visual-replace-apply-one-repeat} executes
@code{visual-replace-apply-one}, then install a transient map that
allows:

@quotation


@itemize *

@item 
repeating @code{visual-replace-apply-one} by typing the last part
of the key sequence used to call @code{visual-replace-apply-one-repeat}

@item 
skipping matches with @code{<down>}, which calls @code{visual-replace-next-match}

@item 
going up the match previews with @code{<up>}, which calls @code{visual-replace-prev-match}

@item 
undoing the last replacement with @code{u}
@end itemize
@end quotation

Typing anything else deactivates the transient map.

This can be configured by modifying the map @code{visual-replace-transient-map}.

This command is available on Emacs 29.1 or later.

@item 
@code{visual-replace-undo} reverts the last call to
@code{visual-replace-apply-one}. This just executes @code{undo} in
the original buffer. With a prefix argument N, call undo N times
instead of just one.
@end itemize

@node Keymaps,Hooks,Commands,Usage
@anchor{usage keymaps}@anchor{e}
@subsection Keymaps


@geindex variable; visual-replace-mode-map
@geindex variable; visual-replace-secondary-mode-map

@code{visual-replace-mode-map} is the map that is active in the
minibuffer in Visual Replace mode. You can add your own keybindings to
it.

@code{visual-replace-secondary-mode-map} is the map that defines
keyboard shortcuts for modifying the search mode, such as @code{r} to
toggle regexp mode on or off. It is bound by default in
@code{visual-replace-mode-map} to the shortcut that was used to
launch Visual Replace, but you can bind it to whatever you want, or
define custom shortcuts directly in @code{visual-replace-mode-map}.

In the example below, @code{C-l} is bound to secondary mode map and
@code{C-r} toggles the regexp mode, so it is possible to toggle the
regexp mode using either @code{C-l r} or @code{C-r}.

@example
(use-package visual-replace
  :defer t
  :bind (("C-c l" . visual-replace)
         :map visual-replace-mode-map
         ("C-r" . visual-replace-toggle-regexp))
  :config
  (define-key visual-replace-mode-map (kbd "C-l")
      visual-replace-secondary-mode-map))
@end example

@node Hooks,Limitations,Keymaps,Usage
@anchor{usage hooks}@anchor{f}
@subsection Hooks


@geindex hook; visual-replace-mode-hook
@geindex hook; visual-replace-functions

@cite{visual-replace-mode-hook} is a normal hook that is run when entering
the visual replace mode, so you can set things up just before Visual
Replace starts.

Functions in @cite{visual-replace-functions} are called just before
executing the replacement or just before building the previews. They
are passed a struct of type @code{visual-replace-args}, which they
can modify. You can use it to customize the behavior of the search or
modify the regexp language.

@node Limitations,,Hooks,Usage
@anchor{usage limitations}@anchor{10}
@subsection Limitations



@itemize *

@item 
Visual Replace avoids executing replacement in the whole buffer
during preview; it just executes them in the parts of the buffer
that are currently visible. This means that the preview can show
incorrect replacement in some cases, such as when replacement uses
@cite{\#} directly or within a @cite{\@comma{}} In such cases, the preview can be
wrong but execution will be correct.

Replacements that call stateful functions in @cite{\@comma{}} such as a
function that increment an internal counter, will be executed too
many times during preview, with unpredictable results.

In all other cases, the preview should match what is eventually
executed. If that’s not the case, please @ref{11,,report an issue}.

@item 
If you use @code{visual-replace-apply-one} to replace single
matches, @code{\#} in the replacement is always 1, because single
matches are applied separately.
@end itemize

@node Contributing,,Usage,Contents
@anchor{contrib doc}@anchor{12}@anchor{contrib contributing}@anchor{13}
@section Contributing


@menu
* Reporting issues:: 
* Suggesting features:: 
* Asking questions:: 
* Code contributions:: 
* Documentation contributions:: 

@end menu

@node Reporting issues,Suggesting features,,Contributing
@anchor{contrib reporting}@anchor{11}@anchor{contrib reporting-issues}@anchor{14}
@subsection Reporting issues


At this time, the most useful thing you can do to help is and useful
bug reports to the Issue Tracker@footnote{https://github.com/szermatt/visual-replace/issues}

In your report, please discuss what you wanted to happen as well as
what happened. Also, please include enough information to reproduce
the issue.

Please include:


@itemize -

@item 
the version of Emacs you’re running, taken, for example, from @code{M-x about-emacs}

@item 
whether you’re running Emacs in a window environment or a terminal

@item 
the OS you’re running

@item 
the replacement mode - a copy of what’s shown in the minibuffer.

@item 
the text you wanted to replace, the replacement text, the
replacement modes - copying the content of minibuffer will do the
trick.
@end itemize

@cartouche
@quotation Tip 
It’s a great idea to take a screenshot of the Emacs window in Visual
Replace mode just before executing it, and then another one after
executing it and attach that to the issue.
@end quotation
@end cartouche

@node Suggesting features,Asking questions,Reporting issues,Contributing
@anchor{contrib issue-tracker}@anchor{15}@anchor{contrib suggesting-features}@anchor{16}
@subsection Suggesting features


Please add feature suggestions to the Issue Tracker@footnote{https://github.com/szermatt/visual-replace/issues}.

@node Asking questions,Code contributions,Suggesting features,Contributing
@anchor{contrib asking-questions}@anchor{17}
@subsection Asking questions


Open an issue on the Issue Tracker@footnote{https://github.com/szermatt/visual-replace/issues} with your question.

@node Code contributions,Documentation contributions,Asking questions,Contributing
@anchor{contrib code-contributions}@anchor{18}
@subsection Code contributions


To contribute code to the project, open a Pull Request@footnote{https://github.com/szermatt/emacs-bash-completion/pulls}.

Before you do that, please make sure the any new features is covered
by tests and that the tests pass.

To run the tests, install and setup eldev@footnote{https://github.com/emacs-eldev/eldev} then run @code{eldev
test}.

Tests can also be run from inside of Emacs, using @cite{M-x ert-run-tests-interactively} but when you do so, be aware that there
might be unexpected interaction with your Emacs configurations. The
tests passing reliably when run using @code{eldev test} is what
matters.

@node Documentation contributions,,Code contributions,Contributing
@anchor{contrib documentation-contributions}@anchor{19}@anchor{contrib eldev}@anchor{1a}
@subsection Documentation contributions


You don’t need to be a developer to contribute! Contribution to the
documentation or code comments are very welcome. Please open a Pull Request@footnote{https://github.com/szermatt/emacs-bash-completion/pulls} with your proposed modifications.

The documentation is written in reStructuredText. You’ll need to
install Sphinx@footnote{https://www.sphinx-doc.org} to build it:

@example
python3 -m venv venv
. venv/bin/activate # or activate.fish on fish
pip3 install -r docs/requirements.txt
@end example

Then run @code{eldev html} to build the documentation.

@node Index,,Contents,Top
@unnumbered Index


@printindex ge


@c %**end of body
@bye
